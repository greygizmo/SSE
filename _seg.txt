            ok_shift = (fm_shift is not None) and (not fm_shift.is_empty()) and (int(fm_shift.select('bought_in_division').to_pandas().sum().iloc[0]) >= 10)
        except Exception:
            ok_shift = False
        if not (ok_base and ok_shift):
            status = "SKIPPED"
            comp = {"reason": "insufficient positives for stable GroupCV folds at base/shift cutoffs"}
        else:
            # Best-effort: train base and shifted cutoff with identical SAFE+GroupCV+purge and compare
            try:
                from gosales.utils.paths import OUTPUTS_DIR as _OUT
                import shutil
                division = ctx.division
                div_key = division.lower()
                met_path = _OUT / f"metrics_{div_key}.json"
                backup_path = None
                if met_path.exists():
                    backup_path = _OUT / f"metrics_{div_key}.json.bak"
                    shutil.copy2(met_path, backup_path)
                # Enforce GroupKFold and purge days; use SAFE mode for Gauntlet training
                from gosales.utils.config import load_config as _load
                _cfg = _load()
                purge = int(getattr(getattr(_cfg, 'validation', object()), 'gauntlet_purge_days', 30) or 30)
                label_buf = int(getattr(getattr(_cfg, 'validation', object()), 'gauntlet_label_buffer_days', 0) or 0)
                def _train_at(cut: str) -> dict:
                    cmd = [
                        sys.executable, "-m", "gosales.models.train",
                        "--division", division,
                        "--cutoffs", cut,
                        "--window-months", str(window_months),
                        "--group-cv",
                        "--purge-days", str(int(purge)),
                        "--safe-mode",
                        "--label-buffer-days", str(int(label_buf)),
                    ]
                    subprocess.run(cmd, check=True)
                    return json.loads(met_path.read_text(encoding="utf-8")) if met_path.exists() else {}
                # Train base and shifted with same SAFE/GroupCV/purge to ensure apples-to-apples
                base_metrics = _train_at(ctx.cutoff)
                shift_metrics = _train_at(cut_shift)
                # Restore original metrics if we backed up; otherwise clean up temp metrics file
                if backup_path and backup_path.exists():
                    shutil.move(str(backup_path), str(met_path))
                else:
                    try:
                        if met_path.exists():
                            met_path.unlink()
                    except Exception:
                        pass
                # Extract comparable metrics
                def _final(m):
                    return m.get("final", {}) if isinstance(m, dict) else {}
                bm = _final(base_metrics)
                sm = _final(shift_metrics)
                # Harmonize lift@10 field name across variants
                def _lift10(d: dict) -> float | None:
                    if d is None:
                        return None
                    v = d.get("lift@10") if isinstance(d, dict) else None
                    if v is None and isinstance(d, dict):
                        v = d.get("lift10")
                    return v
